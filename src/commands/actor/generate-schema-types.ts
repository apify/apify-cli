import { mkdir, writeFile } from 'node:fs/promises';
import path, { join } from 'node:path';
import process from 'node:process';

import type { JSONSchema4 } from 'json-schema';
import { compile, type Options } from 'json-schema-to-typescript';
import deepClone from 'lodash.clonedeep';

import { ApifyCommand } from '../../lib/command-framework/apify-command.js';
import { Args } from '../../lib/command-framework/args.js';
import { Flags } from '../../lib/command-framework/flags.js';
import { LOCAL_CONFIG_PATH } from '../../lib/consts.js';
import {
	readAndValidateInputSchema,
	readDatasetSchema,
	readOutputSchema,
	readStorageSchema,
} from '../../lib/input_schema.js';
import { info, success } from '../../lib/outputs.js';

export const BANNER_COMMENT = `
/* eslint-disable */
/* biome-ignore-all lint */
/* biome-ignore-all format */
/* prettier-ignore-start */
/*
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run apify actor generate-schema-types to regenerate this file.
 */
`;

/**
 * Transforms a JSON schema so that all properties without a `default` value are marked as required.
 * Properties that have a `default` are left optional, since Apify fills them in at runtime.
 * Recurses into nested object properties.
 */
export function makePropertiesRequired(schema: Record<string, unknown>): Record<string, unknown> {
	const clone = deepClone(schema);

	if (!clone.properties || typeof clone.properties !== 'object') {
		return clone;
	}

	const properties = clone.properties as Record<string, Record<string, unknown>>;
	const requiredSet = new Set<string>(Array.isArray(clone.required) ? (clone.required as string[]) : []);

	for (const [key, prop] of Object.entries(properties)) {
		if (prop.default === undefined) {
			requiredSet.add(key);
		} else {
			requiredSet.delete(key);
		}

		if (prop.type === 'object' && prop.properties) {
			properties[key] = makePropertiesRequired(prop) as Record<string, unknown>;
		}
	}

	clone.required = Array.from(requiredSet);

	return clone;
}

/**
 * Deep clones a schema and recursively removes all `required` arrays,
 * making every property optional at all nesting levels.
 */
export function clearAllRequired(schema: Record<string, unknown>): Record<string, unknown> {
	const clone = deepClone(schema);

	delete clone.required;

	if (clone.properties && typeof clone.properties === 'object') {
		const properties = clone.properties as Record<string, Record<string, unknown>>;
		for (const [key, prop] of Object.entries(properties)) {
			if (prop.type === 'object' && prop.properties) {
				properties[key] = clearAllRequired(prop) as Record<string, unknown>;
			}
		}
	}

	return clone;
}

/**
 * Recursively strips `title` from all properties in a schema.
 *
 * When a nested property has a `title`, `json-schema-to-typescript` extracts it
 * as a separate named `export interface`. Stripping titles forces all nested types
 * to be inlined, ensuring only one exported interface per schema.
 */
export function stripTitles(schema: Record<string, unknown>): Record<string, unknown> {
	const clone = deepClone(schema);

	delete clone.title;

	if (clone.properties && typeof clone.properties === 'object') {
		const properties = clone.properties as Record<string, Record<string, unknown>>;
		for (const [key, prop] of Object.entries(properties)) {
			if (prop && typeof prop === 'object') {
				properties[key] = stripTitles(prop) as Record<string, unknown>;
			}
		}
	}

	if (clone.items && typeof clone.items === 'object') {
		clone.items = stripTitles(clone.items as Record<string, unknown>);
	}

	// Recurse into composition keywords (arrays of sub-schemas)
	for (const keyword of ['allOf', 'anyOf', 'oneOf'] as const) {
		if (Array.isArray(clone[keyword])) {
			clone[keyword] = (clone[keyword] as Record<string, unknown>[]).map((subSchema) =>
				subSchema && typeof subSchema === 'object' ? stripTitles(subSchema) : subSchema,
			);
		}
	}

	// Recurse into definitions / $defs (objects mapping names to sub-schemas)
	for (const keyword of ['definitions', '$defs'] as const) {
		if (clone[keyword] && typeof clone[keyword] === 'object' && !Array.isArray(clone[keyword])) {
			const defs = clone[keyword] as Record<string, Record<string, unknown>>;
			for (const [key, def] of Object.entries(defs)) {
				if (def && typeof def === 'object') {
					defs[key] = stripTitles(def) as Record<string, unknown>;
				}
			}
		}
	}

	// Recurse into additionalProperties when it is a schema object
	if (clone.additionalProperties && typeof clone.additionalProperties === 'object') {
		clone.additionalProperties = stripTitles(clone.additionalProperties as Record<string, unknown>);
	}

	return clone;
}

/**
 * Extracts and prepares the `fields` sub-schema from a Dataset or KVS schema for compilation.
 * Returns `null` if the schema has no compilable fields (empty or missing).
 */
export function prepareFieldsSchemaForCompilation(schema: Record<string, unknown>): Record<string, unknown> | null {
	const fields = schema.fields as Record<string, unknown> | undefined;

	if (!fields || typeof fields !== 'object' || !fields.properties || typeof fields.properties !== 'object') {
		return null;
	}

	const clone = deepClone(fields);

	if (!clone.type) {
		clone.type = 'object';
	}

	return clone;
}

/**
 * Prepares an Output schema for compilation by stripping non-JSON-Schema keys.
 *
 * Output schemas have `properties` at the top level where each property always has
 * `type: "string"` and a `template` field (URL construction pattern).
 * We strip `template` since it's not valid JSON Schema.
 *
 * Returns `null` if the schema has no compilable properties.
 */
export function prepareOutputSchemaForCompilation(schema: Record<string, unknown>): Record<string, unknown> | null {
	const properties = schema.properties as Record<string, Record<string, unknown>> | undefined;

	if (!properties || typeof properties !== 'object' || Object.keys(properties).length === 0) {
		return null;
	}

	const clonedProperties = deepClone(properties);

	// Strip non-JSON-Schema keys (like `template`) from each property
	for (const prop of Object.values(clonedProperties)) {
		if (prop && typeof prop === 'object') {
			delete prop.template;
		}
	}

	const result: Record<string, unknown> = {
		type: schema.type || 'object',
		properties: clonedProperties,
	};

	if (Array.isArray(schema.required)) {
		result.required = [...schema.required];
	}

	return result;
}

/**
 * Extracts compilable JSON schemas from KVS collections.
 *
 * KVS schemas use `collections` where each collection can have a `jsonSchema` (Draft 07).
 * Only collections with `jsonSchema` are returned, as non-JSON collections (e.g. images)
 * have no type to generate.
 *
 * Returns an array of `{ name, schema }` pairs, or an empty array if none are found.
 */
export function prepareKvsCollectionsForCompilation(
	schema: Record<string, unknown>,
): { name: string; schema: Record<string, unknown> }[] {
	const collections = schema.collections as Record<string, Record<string, unknown>> | undefined;

	if (!collections || typeof collections !== 'object') {
		return [];
	}

	const result: { name: string; schema: Record<string, unknown> }[] = [];

	for (const [name, collection] of Object.entries(collections)) {
		if (!collection || typeof collection !== 'object') {
			continue;
		}

		const jsonSchema = collection.jsonSchema as Record<string, unknown> | undefined;

		if (!jsonSchema || typeof jsonSchema !== 'object' || Object.keys(jsonSchema).length === 0) {
			continue;
		}

		const clone = deepClone(jsonSchema);

		if (!clone.type) {
			clone.type = 'object';
		}

		result.push({ name, schema: clone });
	}

	return result;
}

export class ActorGenerateSchemaTypesCommand extends ApifyCommand<typeof ActorGenerateSchemaTypesCommand> {
	static override name = 'generate-schema-types' as const;

	static override hiddenAliases = ['generate-types'];

	static override description = `Generate TypeScript types from Actor schemas.

Generates types from the input schema and, when no custom path is provided,
also from the Dataset, Output (experimental), and Key-Value Store (experimental)
schemas defined in '${LOCAL_CONFIG_PATH}'.

Reads the input schema from one of these locations (in priority order):
  1. Object in '${LOCAL_CONFIG_PATH}' under "input" key
  2. JSON file path in '${LOCAL_CONFIG_PATH}' "input" key
  3. .actor/INPUT_SCHEMA.json
  4. INPUT_SCHEMA.json

Optionally specify custom schema path to use.`;

	static override flags = {
		output: Flags.string({
			char: 'o',
			description:
				'Directory where the generated files should be outputted. Defaults to src/.generated/actor/ to stay within the typical tsconfig rootDir.',
			required: false,
			default: join('src', '.generated', 'actor'),
		}),
		strict: Flags.boolean({
			description: 'Whether generated interfaces should be strict (no index signature [key: string]: unknown).',
			required: false,
			default: true,
		}),
		'all-optional': Flags.boolean({
			description: 'Mark all properties as optional in generated types.',
			required: false,
			default: false,
		}),
	};

	static override args = {
		path: Args.string({
			required: false,
			description: 'Optional path to the input schema file. If not provided, searches default locations.',
		}),
	};

	async run() {
		const cwd = process.cwd();

		const { inputSchema } = await readAndValidateInputSchema({
			forcePath: this.args.path,
			cwd,
			action: 'Generating types from',
		});

		const name = 'input';

		const schemaToCompile = this.flags.allOptional
			? clearAllRequired(inputSchema)
			: makePropertiesRequired(inputSchema);

		const compileOptions: Partial<Options> = {
			bannerComment: BANNER_COMMENT,
			maxItems: -1,
			unknownAny: true,
			format: true,
			additionalProperties: !this.flags.strict,
			$refOptions: { resolve: { external: false, file: false, http: false } },
		};

		const result = await compile(stripTitles(schemaToCompile) as JSONSchema4, name, compileOptions);

		const outputDir = path.resolve(cwd, this.flags.output);
		await mkdir(outputDir, { recursive: true });

		const outputFile = path.join(outputDir, `${name}.ts`);
		await writeFile(outputFile, result, 'utf-8');

		success({ message: `Generated types written to ${outputFile}` });

		// When no custom path is provided, also generate types from additional schemas
		if (!this.args.path) {
			await Promise.all([
				this.generateDatasetTypes({ cwd, outputDir, compileOptions }),
				this.generateOutputTypes({ cwd, outputDir, compileOptions }),
				this.generateKvsTypes({ cwd, outputDir, compileOptions }),
			]);
		}
	}

	private async generateDatasetTypes({
		cwd,
		outputDir,
		compileOptions,
	}: {
		cwd: string;
		outputDir: string;
		compileOptions: Partial<Options>;
	}) {
		const datasetResult = readDatasetSchema({ cwd });

		if (!datasetResult) {
			return;
		}

		const { datasetSchema, datasetSchemaPath } = datasetResult;

		if (datasetSchemaPath) {
			info({ message: `[experimental] Generating types from Dataset schema at ${datasetSchemaPath}` });
		} else {
			info({ message: `[experimental] Generating types from Dataset schema embedded in '${LOCAL_CONFIG_PATH}'` });
		}

		const prepared = prepareFieldsSchemaForCompilation(datasetSchema);

		if (!prepared) {
			info({ message: 'Dataset schema has no fields defined, skipping type generation.' });
			return;
		}

		const datasetName = 'dataset';

		const schemaToCompile = this.flags.allOptional ? clearAllRequired(prepared) : prepared;

		const result = await compile(stripTitles(schemaToCompile) as JSONSchema4, datasetName, compileOptions);

		const outputFile = path.join(outputDir, `${datasetName}.ts`);
		await writeFile(outputFile, result, 'utf-8');

		success({ message: `Generated types written to ${outputFile}` });
	}

	private async generateOutputTypes({
		cwd,
		outputDir,
		compileOptions,
	}: {
		cwd: string;
		outputDir: string;
		compileOptions: Partial<Options>;
	}) {
		const outputResult = readOutputSchema({ cwd });

		if (!outputResult) {
			return;
		}

		const { outputSchema, outputSchemaPath } = outputResult;

		if (outputSchemaPath) {
			info({ message: `[experimental] Generating types from Output schema at ${outputSchemaPath}` });
		} else {
			info({ message: `[experimental] Generating types from Output schema embedded in '${LOCAL_CONFIG_PATH}'` });
		}

		const prepared = prepareOutputSchemaForCompilation(outputSchema);

		if (!prepared) {
			info({ message: 'Output schema has no properties defined, skipping type generation.' });
			return;
		}

		const outputName = 'output';

		const schemaToCompile = this.flags.allOptional ? clearAllRequired(prepared) : prepared;

		const result = await compile(stripTitles(schemaToCompile) as JSONSchema4, outputName, compileOptions);

		const outputFile = path.join(outputDir, `${outputName}.ts`);
		await writeFile(outputFile, result, 'utf-8');

		success({ message: `Generated types written to ${outputFile}` });
	}

	private async generateKvsTypes({
		cwd,
		outputDir,
		compileOptions,
	}: {
		cwd: string;
		outputDir: string;
		compileOptions: Partial<Options>;
	}) {
		const kvsResult = readStorageSchema({ cwd, key: 'keyValueStore', label: 'Key-Value Store' });

		if (!kvsResult) {
			return;
		}

		const { schema: kvsSchema, schemaPath: kvsSchemaPath } = kvsResult;

		if (kvsSchemaPath) {
			info({ message: `[experimental] Generating types from Key-Value Store schema at ${kvsSchemaPath}` });
		} else {
			info({
				message: `[experimental] Generating types from Key-Value Store schema embedded in '${LOCAL_CONFIG_PATH}'`,
			});
		}

		const collections = prepareKvsCollectionsForCompilation(kvsSchema);

		if (collections.length === 0) {
			info({ message: 'Key-Value Store schema has no collections with JSON schemas, skipping type generation.' });
			return;
		}

		const parts: string[] = [];

		for (const { name, schema } of collections) {
			const schemaToCompile = this.flags.allOptional ? clearAllRequired(schema) : schema;

			const compiled = await compile(stripTitles(schemaToCompile) as JSONSchema4, name, {
				...compileOptions,
				// Only the first collection gets the banner comment
				bannerComment: parts.length === 0 ? (compileOptions.bannerComment as string) : '',
			});

			parts.push(compiled);
		}

		const outputFile = path.join(outputDir, 'key-value-store.ts');
		await writeFile(outputFile, parts.join('\n'), 'utf-8');

		success({ message: `Generated types written to ${outputFile}` });
	}
}
