import { mkdir, writeFile } from 'node:fs/promises';
import path, { join } from 'node:path';
import process from 'node:process';

import type { JSONSchema4 } from 'json-schema';
import { compile, type Options } from 'json-schema-to-typescript';

import { ApifyCommand } from '../../lib/command-framework/apify-command.js';
import { Args } from '../../lib/command-framework/args.js';
import { Flags } from '../../lib/command-framework/flags.js';
import { CommandExitCodes, LOCAL_CONFIG_PATH } from '../../lib/consts.js';
import {
	readAndValidateInputSchema,
	readDatasetSchema,
	readOutputSchema,
	readStorageSchema,
} from '../../lib/input_schema.js';
import { error, info, success } from '../../lib/outputs.js';
import {
	clearAllRequired,
	makePropertiesRequired,
	prepareFieldsSchemaForCompilation,
	prepareKvsCollectionsForCompilation,
	prepareOutputSchemaForCompilation,
	stripTitles,
} from '../../lib/schema-transforms.js';

export const BANNER_COMMENT = `
// biome-ignore-all lint: generated
// biome-ignore-all format: generated
/* eslint-disable */
/* prettier-ignore-start */
/*
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run apify actor generate-schema-types to regenerate this file.
 */
`;

export class ActorGenerateSchemaTypesCommand extends ApifyCommand<typeof ActorGenerateSchemaTypesCommand> {
	static override name = 'generate-schema-types' as const;

	static override hiddenAliases = ['generate-types'];

	static override description = `Generate TypeScript types from Actor schemas.

Generates types from the input schema and, when no custom path is provided,
also from the Dataset, Output (experimental), and Key-Value Store (experimental)
schemas defined in '${LOCAL_CONFIG_PATH}'.

Reads the input schema from one of these locations (in priority order):
  1. Object in '${LOCAL_CONFIG_PATH}' under "input" key
  2. JSON file path in '${LOCAL_CONFIG_PATH}' "input" key
  3. .actor/INPUT_SCHEMA.json
  4. INPUT_SCHEMA.json

Optionally specify custom schema path to use.`;

	static override flags = {
		output: Flags.string({
			char: 'o',
			description:
				'Directory where the generated files should be outputted. Defaults to src/.generated/actor/ to stay within the typical tsconfig rootDir.',
			required: false,
			default: join('src', '.generated', 'actor'),
		}),
		strict: Flags.boolean({
			description: 'Whether generated interfaces should be strict (no index signature [key: string]: unknown).',
			required: false,
			default: true,
		}),
		'all-optional': Flags.boolean({
			description: 'Mark all properties as optional in generated types.',
			required: false,
			default: false,
		}),
	};

	static override args = {
		path: Args.string({
			required: false,
			description: 'Optional path to the input schema file. If not provided, searches default locations.',
		}),
	};

	async run() {
		const cwd = process.cwd();

		const { inputSchema } = await readAndValidateInputSchema({
			forcePath: this.args.path,
			cwd,
			action: 'Generating types from',
		});

		const name = 'input';

		const schemaToCompile = this.flags.allOptional
			? clearAllRequired(inputSchema)
			: makePropertiesRequired(inputSchema);

		const compileOptions: Partial<Options> = {
			bannerComment: BANNER_COMMENT,
			maxItems: -1,
			unknownAny: true,
			format: true,
			additionalProperties: !this.flags.strict,
			$refOptions: { resolve: { external: false, file: false, http: false } },
		};

		const result = await compile(stripTitles(schemaToCompile) as JSONSchema4, name, compileOptions);

		const outputDir = path.resolve(cwd, this.flags.output);
		await mkdir(outputDir, { recursive: true });

		const outputFile = path.join(outputDir, `${name}.ts`);
		await writeFile(outputFile, result, 'utf-8');

		success({ message: `Generated types written to ${outputFile}` });

		// When no custom path is provided, also generate types from additional schemas
		if (!this.args.path) {
			const schemaResults = await Promise.allSettled([
				this.generateDatasetTypes({ cwd, outputDir, compileOptions }),
				this.generateOutputTypes({ cwd, outputDir, compileOptions }),
				this.generateKvsTypes({ cwd, outputDir, compileOptions }),
			]);

			const schemaLabels = ['Dataset', 'Output', 'Key-Value Store'];
			let anyFailed = false;

			for (const [i, schemaResult] of schemaResults.entries()) {
				if (schemaResult.status === 'rejected') {
					anyFailed = true;
					error({
						message: `Failed to generate types for ${schemaLabels[i]} schema: ${schemaResult.reason instanceof Error ? schemaResult.reason.message : String(schemaResult.reason)}`,
					});
				}
			}

			if (anyFailed) {
				process.exitCode = CommandExitCodes.BuildFailed;
			}
		}
	}

	private async generateDatasetTypes({
		cwd,
		outputDir,
		compileOptions,
	}: {
		cwd: string;
		outputDir: string;
		compileOptions: Partial<Options>;
	}) {
		const datasetResult = readDatasetSchema({ cwd });

		if (!datasetResult) {
			return;
		}

		const { datasetSchema, datasetSchemaPath } = datasetResult;

		if (datasetSchemaPath) {
			info({ message: `[experimental] Generating types from Dataset schema at ${datasetSchemaPath}` });
		} else {
			info({ message: `[experimental] Generating types from Dataset schema embedded in '${LOCAL_CONFIG_PATH}'` });
		}

		const prepared = prepareFieldsSchemaForCompilation(datasetSchema);

		if (!prepared) {
			info({ message: 'Dataset schema has no fields defined, skipping type generation.' });
			return;
		}

		const datasetName = 'dataset';

		const schemaToCompile = this.flags.allOptional ? clearAllRequired(prepared) : prepared;

		const result = await compile(stripTitles(schemaToCompile) as JSONSchema4, datasetName, compileOptions);

		const outputFile = path.join(outputDir, `${datasetName}.ts`);
		await writeFile(outputFile, result, 'utf-8');

		success({ message: `Generated types written to ${outputFile}` });
	}

	private async generateOutputTypes({
		cwd,
		outputDir,
		compileOptions,
	}: {
		cwd: string;
		outputDir: string;
		compileOptions: Partial<Options>;
	}) {
		const outputResult = readOutputSchema({ cwd });

		if (!outputResult) {
			return;
		}

		const { outputSchema, outputSchemaPath } = outputResult;

		if (outputSchemaPath) {
			info({ message: `[experimental] Generating types from Output schema at ${outputSchemaPath}` });
		} else {
			info({ message: `[experimental] Generating types from Output schema embedded in '${LOCAL_CONFIG_PATH}'` });
		}

		const prepared = prepareOutputSchemaForCompilation(outputSchema);

		if (!prepared) {
			info({ message: 'Output schema has no properties defined, skipping type generation.' });
			return;
		}

		const outputName = 'output';

		const schemaToCompile = this.flags.allOptional ? clearAllRequired(prepared) : prepared;

		const result = await compile(stripTitles(schemaToCompile) as JSONSchema4, outputName, compileOptions);

		const outputFile = path.join(outputDir, `${outputName}.ts`);
		await writeFile(outputFile, result, 'utf-8');

		success({ message: `Generated types written to ${outputFile}` });
	}

	private async generateKvsTypes({
		cwd,
		outputDir,
		compileOptions,
	}: {
		cwd: string;
		outputDir: string;
		compileOptions: Partial<Options>;
	}) {
		const kvsResult = readStorageSchema({ cwd, key: 'keyValueStore', label: 'Key-Value Store' });

		if (!kvsResult) {
			return;
		}

		const { schema: kvsSchema, schemaPath: kvsSchemaPath } = kvsResult;

		if (kvsSchemaPath) {
			info({ message: `[experimental] Generating types from Key-Value Store schema at ${kvsSchemaPath}` });
		} else {
			info({
				message: `[experimental] Generating types from Key-Value Store schema embedded in '${LOCAL_CONFIG_PATH}'`,
			});
		}

		const collections = prepareKvsCollectionsForCompilation(kvsSchema);

		if (collections.length === 0) {
			info({ message: 'Key-Value Store schema has no collections with JSON schemas, skipping type generation.' });
			return;
		}

		const parts: string[] = [];

		for (const { name, schema } of collections) {
			const schemaToCompile = this.flags.allOptional ? clearAllRequired(schema) : schema;

			const compiled = await compile(stripTitles(schemaToCompile) as JSONSchema4, name, {
				...compileOptions,
				// Only the first collection gets the banner comment
				bannerComment: parts.length === 0 ? (compileOptions.bannerComment as string) : '',
			});

			parts.push(compiled);
		}

		const outputFile = path.join(outputDir, 'key-value-store.ts');
		await writeFile(outputFile, parts.join('\n'), 'utf-8');

		success({ message: `Generated types written to ${outputFile}` });
	}
}
